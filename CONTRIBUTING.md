# How to help

Oh my goodness how lucky (We/I) am that you are taking the time to read this document.
Thank you for reviewing how you can be of help to this endevour. 
Please let me start by stating the below suggested reading is in no-way required for people to contribute.
Questions, concerns, impressions, and all other sorts of feedback are equally welcome to that of technical contributions in the form of documentation and code.

If you are unfamiliar with the concept of approval voting, please consider checking out the Wikipedia Article on it.

Along with information about Approval voting specifically a background on other ways of voting might be useful too.
1) Plurality voting (what we largely use)
2) Ranked Choice & Runoff voting (another system proposed in alternative to Approval Voting.)

## Testing

For versions prior to 0.1 (so 0.0.0 ... 0.0.9x) there will be no requirement for testing or coverage, the goal is just a running prototype to examine and evaluate the process.
For now I'm setting hazy code-coverage & passing test goals for each minor-revision between 0.1 & 1.0; where version 0.1.0's goal is to have %10 code coverage and %10 passing tests.
Each additional version will have higher goals; until we reach 100% coverage & 100% passing tests for version 1.0.

## Your changes

The Wiki, the Issues are completely open for anyone to contribute too.
For now; this is ALSO true of the master repository; I encourage anyone to submit pull requests directly to it for evaluation.

In the future we will have designated "master"(latest release, locked), "latest-rc"(next like release version, locked) branches.. as noted these two will be locked to ensure
errant code is never pushed to them by mistake.  A "master-security-fixes" branch will exist; along with a "master-fixes" branch that will offer the latest "fixes" with the "security-fixes" branch havign a shorter turn-arround for approving updates to it than the "fixes" branch.
Allong with all these locked; and semi-locked branches the goal is to have different "development" branches; center around topics of active development (new feature, depreciation of old features, refactoring/module work, documentation/admin work.)

## Conventions 

As of yet; no "conventions" for code, documentation, or other content has been defined.
Keeping in mind the goal of this is to garner as many "peer-reviewers" as possible; care should be taken to follow "conventions" of the open-source community at large.
Care should be given to present this software in a way that is "native" to each "peer-reviewers" platform (as much as possible.)
Mobile device users and "peer" developers should be able to think of this software applications in terms that make sense (Services, Screens/Pages, Widgets/Buttons; Text/Input)
and similarly unix hackers should also be able to think of this software application in therms that make sense (stdin, stdout, stderr, sockets, ports, files, folders).

To that end, generally this project should be hesitant to define conventions, defining them only when nessicary for collaboration purposes, and generally attempting to follow or otherwise be compatible with "larger" conventions in the open software field.


## Thank you.

Thanks from Jon David Sawyer, for taking the time to check this idea out, and considering contributing to it's success.
